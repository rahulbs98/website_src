<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Publications - Rahul Satish</title>
  <link rel="stylesheet" href="assets/css/style.css">
  <script src="assets/js/components.js" defer></script>
</head>
<body>
  <header>
    <nav>
      <a href="index.html" class="logo">Rahul Satish</a>
      <a href="about.html">About</a>
      <a href="publications.html">Publications</a>
      <a href="blog.html">Blog</a>
      <a href="albums/" target="_blank">Albums</a>
      <a href="assets/data/cv.pdf" target="_blank">CV</a>
      <button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
    </nav>
  </header>

  <main>
    <h1>Research Publications</h1>
    
    <div class="pub-filters">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="conference">Conferences</button>
      <button class="filter-btn" data-filter="journal">Journals</button>
      <button class="filter-btn" data-filter="eprint">eprints</button>
    </div>

    <div id="publication-list" class="pub-list">
      <!-- Publications will be loaded here dynamically -->
    </div>
    
    <div id="pub-placeholder" class="empty-state" style="display:none;">
      <p>Loading publications...</p>
    </div>
  </main>

  <script>
    /**
     * Publications Manager - Loads from BibTeX JSON
     */
    class PublicationsManager {
      constructor() {
        this.allPubs = [];
        this.filteredPubs = [];
      }

      async loadPublications() {
        try {
          const response = await fetch('assets/data/publications.json');
          const data = await response.json();
          this.allPubs = this.processBibTeXData(data);
          this.filteredPubs = this.allPubs;
          this.render();
          this.setupFilters();
        } catch (error) {
          console.error('Error loading publications:', error);
          document.getElementById('pub-placeholder').style.display = 'block';
          document.getElementById('pub-placeholder').textContent = 'Error loading publications.';
        }
      }

      processBibTeXData(bibTeXArray) {
        return bibTeXArray.map(entry => {
          const tags = entry.entryTags;
          const journalStr = (tags.journal || '').toLowerCase();
          const entryType = (entry.entryType || '').toLowerCase();

          // Determine publication type based on journal/type name
          let pubType = 'eprint';
          if (journalStr.includes('eprint') || journalStr.includes('iacr')) {
            pubType = 'eprint';
          } else if (journalStr.includes('conference') || entryType === 'inproceedings') {
            pubType = 'conference';
          } else if (entryType === 'article' || journalStr.includes('journal')) {
            pubType = 'journal';
          }

          return {
            id: entry.citationKey,
            title: this.cleanText(tags.title || ''),
            authors: this.formatAuthors(tags.author || ''),
            year: tags.year || '',
            type: pubType,
            venue: this.cleanText(tags.journal || tags.booktitle || 'Unknown Venue'),
            url: tags.url || '',
            pages: tags.pages || '',
            abstract: tags.abstract || 'No abstract available',
            tags: this.extractTags(tags.title, tags.keywords)
          };
        }).sort((a, b) => parseInt(b.year) - parseInt(a.year));
      }

      cleanText(text) {
        if (!text) return '';
        return text
          .replace(/{|}/g, '')
          .replace(/\\"/g, '"')
          .replace(/\\'/g, "'")
          .trim();
      }

      formatAuthors(authorStr) {
        if (!authorStr) return 'Unknown Authors';
        return authorStr
          .split(' and ')
          .map(author => author.trim())
          .join(', ');
      }

      extractTags(title, keywords) {
        if (!title) return [];
        const titleWords = title.toLowerCase().split(' ');
        const cryptoTerms = ['mpc', 'zkproof', 'garbling', 'cryptography', 
                            'privacy', 'secure', 'blockchain', 'abe'];
        return titleWords.filter(word => 
          cryptoTerms.some(term => word.includes(term))
        ).slice(0, 3);
      }

      filter(type) {
        if (type === 'all') {
          this.filteredPubs = this.allPubs;
        } else {
          this.filteredPubs = this.allPubs.filter(pub => pub.type === type);
        }
        this.render();
      }

      render() {
        const container = document.getElementById('publication-list');
        const placeholder = document.getElementById('pub-placeholder');

        if (this.filteredPubs.length === 0) {
          container.style.display = 'none';
          placeholder.style.display = 'block';
          placeholder.textContent = 'No publications in this category.';
          return;
        }

        container.style.display = 'flex';
        placeholder.style.display = 'none';

        container.innerHTML = this.filteredPubs.map(pub => `
          <div class="pub-card">
            <p class="pub-meta">${pub.year}</p>
            <div>
              <h3>${pub.title}</h3>
              <p class="pub-authors">${pub.authors} Â· <em>${pub.venue}</em></p>
            </div>
            ${pub.url ? `<a href="${pub.url}" target="_blank">View â†’</a>` : ''}
          </div>
        `).join('');
      }

      setupFilters() {
        const buttons = document.querySelectorAll('.filter-btn');
        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            buttons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const filter = btn.getAttribute('data-filter');
            this.filter(filter);
          });
        });
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      const pubManager = new PublicationsManager();
      pubManager.loadPublications();
    });
  </script>

</body>
</html>